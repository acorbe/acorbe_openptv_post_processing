""" Python script and functions that convert the ptv_is.* database 
generated by OpenPTV (for the crowd tracking experiment) into the Python data
structures of Particles, Frames, List of Frames, Trajectories and plots the data
"""
import os
import glob
import numpy as np
import sys
import matplotlib.pyplot as plt
from matplotlib import is_interactive as mpl_is_interactive
from matplotlib import pylab

from  Data_classes import *
from  traj_processing import *


RESULTS_FOLDER='/../results/'

        
def frame_from_file(filename):
    """ frame_from_file(filename) reads the data
    in the given file into a frame as a list
    of the particles
    """
    t = int(filename.split('.')[-1])
    with open(filename) as f:
        np = int(f.readline())
        frame = Frame()
        for i in range(np):
            p = Particle()
            vals = f.readline().split()
            p.p = int(vals[0])
            p.n = int(vals[1])
            p.x = float(vals[2])/1000. # mm to meter
            p.y = float(vals[3])/1000. # mm to meter
            p.z = float(vals[4])/1000. # mm to meter
            p.t = t
            frame.append(p)
    return frame

def key_ptv_files_sorting(el):
    return int(os.path.splitext(el)[1][1:])
                        
def read_ptv_data_from_directory(directory,first=None,last=None):
	""" 
        directory = '/Users/alex/esktop/crowd_tracking/res/'
        data = read_ptv_data_from_directory(directory,38940,38970)
	"""
        print "\t\tGetting file list..."
	d = glob.glob(os.path.join(directory,'ptv_is.*'))
        print "\t\tSorting..."
	d.sort(key=key_ptv_files_sorting)

        print "\t\tAdjusting extrema..."
	dlist = [int(os.path.splitext(name)[1][1:]) for name in d]
	if first is None or first < dlist[0]:
		first = 0
	else:
		first = dlist.index(first)
#
	if last is None or last > dlist[-1]:
		last = -1
	else:
		last = dlist.index(last)
	
	
	d = d[first:last] # only files between first and last
	dlist = dlist[first:last]
	data = []
	
        tot_files = len(d)

        print "\t\tGenerating struct 'data'..."
        print "...",
	for ind,filename in enumerate(d):
            print "\r\t\t" + str(ind) + "/" + str(tot_files),
            sys.stdout.flush()
            data.append(frame_from_file(filename))

#        print dlist
	
	return data
    
    
def link_trajectories(data):
    """ performs linking of the particles in the frame according to their
    attributes provided by the OpenPTV: previous and next (or left and right)
    Particles are assigned a unique identity during this operation <- this is the output necessary to build traj structure
    """
    id = 0
    # first frame, assign the id to the first frame
    # particles in ascending order, starting from 0
    for particle in data[0]:
        if particle.n != -2:
            particle.id = id
            id += 1
    for ind,frame in enumerate(data[1:]):
        #print '---------------------------'
        #print ind, frame
        past = data[ind]
        for particle in frame:
            # print 'prev = ', particle.p
            if particle.p == -1: # no past
                if particle.n == -2: # no future
                    pass
                    # frame.remove(particle)
                else:
                    particle.id = id #  new id
                    id += 1 # update lastid
            else:
                
                #print 'prev =',particle.p
                #print 'id = ',past[int(particle.p)].id
                particle.id = past[int(particle.p)].id
        #print ind, frame

    return id #lastid

def clean_data(data):
    """ clean_data(data) removes the unlinked
    particles and empty frames
    """

    unidentif_particle_val = Particle.UNIDENTIFIED_PARTICLE #should be faster

    for frame in data:
        fitered_array = [p for p in frame if p.id != unidentif_particle_val]
        frame[:] = fitered_array

    # for particle in frame:
    #     if particle.id == unidentif_particle_val: #particle.is_unidentified():  #
    #         frame.remove(particle)
        
    # for frame in data[-1:0:-1]: # reverse reading
    #      if len(frame) == 0:
    #         data.remove(frame)

    filtered_array = [f for f in data[-1:0:-1] if len(f) != 0]
    data[:] = filtered_array[-1:0:-1]
            
    return data
            
 
def frames_to_traj(data,lastid=None):
    """ converts data from frames of particles into 
    trajectories of particles, using unique identities
    """
    if lastid == None:
        id = []
        for f in data:
            for p in f:
                id.append(p.id)
        
        lastid = max(id)
                
    # prepare the dataset
    traj = [Trajectory() for i in range(lastid+1)]    
    for frame in data:
        for particle in frame:
            try:
                traj[particle.id].append(particle)
            except:
                print len(traj)
                print particle
                print particle.id
                
                
    for t in traj:
        if len(t) < 3:
            traj.remove(t)
            
    return traj 
            
 


if __name__ == '__main__':

     if mpl_is_interactive():
        pylab.ioff()

     try:
        directory = sys.argv[1]
        seq_first = int(sys.argv[2])

        seq_last = int(sys.argv[3])

        #run_batch(eval(seq_first),eval(seq_last))

        print "target dir is", directory
        print "Considered elements: " , seq_first,seq_last
        
     except:
        print("something wrong with the software or folder")
        #general.printException()

     #directory = '../res'
     # Note that the data is stored in millimeters
     # time is given in frames
     fps = 15 #4.16  # frames-per-second
     
     # data = read_ptv_data_from_directory(directory,38940,38999)

     print "reading data..."
     data = read_ptv_data_from_directory(directory,seq_first,seq_last)
     print "\tdone!"
     print "linking trajectories..."
     link_trajectories(data)
     print "\tdone!"

     print "cleaning data..."
     tmp = len(data)
     clean_data(data)
     while len(data) != tmp:
        clean_data(data)
        tmp = len(data)

     print "\tdone!"
     
     #spline substitution can be put in next step.
     print "extracting trajectories..."
     traj = frames_to_traj(data)
     print "\tdone!"
     
      
     calculate_velocity(traj,fps)
     calculate_acceleration(traj,fps)
     # plot_all_trajectories(traj)

     
     print "dumping data..."
     np.savez(os.path.join(directory + RESULTS_FOLDER,'ptv_is'),\
                 data=data,traj=traj)
     print "\tdone"


     plot_colored_trajectories(traj)
     plt.savefig(directory +RESULTS_FOLDER + 'Direction_colored_vmap.png')

     
     
     #input('waiting...')
     
     
     # example of the histogram of velocity
     u = []
     v = []
     t = []
     x = []
     y = []
     id = []
     for f in data:
         for p in f:
             # vel.append(p.u**2 + p.v**2)
             x.append(p.x)
             y.append(p.y)
             u.append(p.u)
             v.append(p.v)
             t.append(p.t)
             id.append(p.id)
     
     x = np.asarray(x)
     y = np.asarray(y)
     u = np.asarray(u)
     v = np.asarray(v)
     t = np.asarray(t)
     id = np.asarray(id)
     t = (t - t[0])/fps  
     vel = u**2 + v**2 
              
     # vel = [i**2 + j**2 for i,j in zip(u,v)]  
     plt.figure()  
     plt.plot(t,vel)
     plt.xlabel('t')
     plt.ylabel('velocity')
     plt.savefig(directory +RESULTS_FOLDER + 'velocity_vtime.png')
     
     plt.figure()
     plt.hist(vel,100)
     plt.xlabel('velocity')
     plt.ylabel('histogram')
     
     plt.savefig(directory +RESULTS_FOLDER + 'velocity_hist.png')
     
     
    # np.savez(os.path.join('/Users/alex/Desktop/crowd_tracking','xyuvtid'),\
    # x=x,y=y,u=u,v=v,t=t,id=id)
     
     
     plt.figure()
     plt.hist2d(x,u,bins=100,range=[[-1,1.3],[-2,2]])
     plt.title('speed vs position')
     plt.xlabel('x [m]')
     plt.ylabel('u [m/s]')
     plt.colorbar()
     
     plt.savefig(directory +RESULTS_FOLDER + 'lspeedVpos.png')
     
     plt.figure()
     plt.hist2d(x,v,bins=100,range=[[-1,1.3],[-2,2]])
     plt.title('transverse speed vs position')
     plt.xlabel('x [m]')
     plt.ylabel('v [m/s]')
     plt.colorbar()
     
     plt.savefig(directory +RESULTS_FOLDER + 'tspeedVpos.png')
     
     plt.figure()
     plt.hist2d(u,v,bins=100,range=[[-1,1],[-1,1]])
     plt.title('transverse vel vs vel')
     plt.xlabel('u [m/s]')
     plt.ylabel('v [m/s]')
     plt.colorbar()

     
     plt.savefig(directory +RESULTS_FOLDER + 'vVv.png')
     
     
     # compare single person speed vs multi-person speed
     single_u, single_v, dense_u, dense_v = [],[],[],[]
     for f in data:
         if len(f) == 1: # single person frame
             single_u.append(f[0].u)
             single_v.append(f[0].v)
         elif len(f) > 3: # multi person frame
             for p in f:
                 dense_u.append(p.u)
                 dense_v.append(p.v)
                
     plt.figure()
     plt.hist(dense_u,100,color='b',normed=True)
     plt.hist(single_u,100,color='r',normed=True)
     plt.title('single vs dense velocity')
     plt.legend(('dense','single'))

     plt.savefig(directory +RESULTS_FOLDER + 'singleVdensev.png')
     
     plt.figure()
     plt.hist(dense_v,100,color='b',normed=True)
     plt.hist(single_v,100,color='r',normed=True)
     plt.title('single vs dense transverse velocity')

     plt.savefig(directory +RESULTS_FOLDER + 'singleVdensetv.png')
                
     plt.figure()
     plt.hist(dense_u,100,color='b',normed=True,log=True)
     plt.hist(single_u,100,color='r',normed=True,log=True)
     plt.title('single vs dense velocity')
     plt.legend(('dense','single'))

     plt.savefig(directory +RESULTS_FOLDER + 'singleVdensevLog.png')
     
     plt.figure()
     plt.hist(dense_v,100,color='b',normed=True,log=True)
     plt.hist(single_v,100,color='r',normed=True,log=True)
     plt.title('single vs dense transverse velocity')
     
     plt.savefig(directory +RESULTS_FOLDER + 'singleVdensetvLog.png')
          

     # compare single person speed vs multi-person speed
     single_ax, single_ay, dense_ax, dense_ay = [],[],[],[]
     for f in data:
         if len(f) == 1: # single person frame
             single_ax.append(f[0].ax)
             single_ay.append(f[0].ay)
         elif len(f) > 3: # multi person frame
             for p in f:
                 dense_ax.append(p.ax)
                 dense_ay.append(p.ay)
                
     plt.figure()
     plt.hist(dense_ax,100,color='b',normed=True)
     plt.hist(single_ax,100,color='r',normed=True)
     plt.title('single vs dense acceleration')
     plt.legend(('dense','single'))
     
     plt.savefig(directory +RESULTS_FOLDER + 'singleVdensea.png')

     plt.figure()
     plt.hist(dense_ay,100,color='b',normed=True)
     plt.hist(single_ay,100,color='r',normed=True)
     plt.title('single vs dense transverse acceleration')
     plt.legend(('dense','single'))

     plt.savefig(directory +RESULTS_FOLDER + 'singleVdenseta.png')

               
     plt.figure()
     plt.hist(dense_ax,100,color='b',normed=True,log=True)
     plt.hist(single_ax,100,color='r',normed=True,log=True)
     plt.title('single vs dense acceleration')
     plt.legend(('dense','single'))
     
     plt.savefig(directory +RESULTS_FOLDER + 'singleVdenseaLog.png')

     plt.figure()
     plt.hist(dense_ay,100,color='b',normed=True,log=True)
     plt.hist(single_ay,100,color='r',normed=True,log=True)
     plt.title('single vs dense transverse acceleration')
     plt.legend(('dense','single'))

     plt.savefig(directory +RESULTS_FOLDER + 'singleVdensetaLog.png')
     

     plt.show(block=True)     
    

